"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GatewayTimeoutError = exports.ServiceUnavailableError = exports.BadGatewayError = exports.NotImplementedError = exports.InternalServiceError = exports.ConflictError = exports.NotFoundError = exports.ForbiddenError = exports.UnauthorizedError = exports.BadParameterError = exports.BadRequestError = exports.NotUpdatedError = exports.HttpError = void 0;
exports.isHttpError = isHttpError;
exports.getErrorMessage = getErrorMessage;
exports.getMessageIfHttpError = getMessageIfHttpError;
exports.isError = isError;
exports.getMessageIfError = getMessageIfError;
const transformNonJsonStringToJsonString = (message) => {
    if (!message) {
        return;
    }
    try {
        JSON.parse(message);
        return message;
    }
    catch (_a) {
        return JSON.stringify({ message });
    }
};
class HttpError extends Error {
    constructor(status, message) {
        super(transformNonJsonStringToJsonString(message));
        this.status = status;
    }
}
exports.HttpError = HttpError;
class NotUpdatedError extends HttpError {
    constructor(message) {
        super(304, message);
    }
}
exports.NotUpdatedError = NotUpdatedError;
class BadRequestError extends HttpError {
    constructor(message) {
        super(400, message);
    }
}
exports.BadRequestError = BadRequestError;
class BadParameterError extends HttpError {
    constructor(message) {
        super(400, message);
    }
}
exports.BadParameterError = BadParameterError;
class UnauthorizedError extends HttpError {
    constructor(message) {
        super(401, message);
    }
}
exports.UnauthorizedError = UnauthorizedError;
class ForbiddenError extends HttpError {
    constructor(message) {
        super(403, message);
    }
}
exports.ForbiddenError = ForbiddenError;
class NotFoundError extends HttpError {
    constructor(message) {
        super(404, message);
    }
}
exports.NotFoundError = NotFoundError;
class ConflictError extends HttpError {
    constructor(message) {
        super(409, message);
    }
}
exports.ConflictError = ConflictError;
class InternalServiceError extends HttpError {
    constructor(message) {
        super(500, message);
    }
}
exports.InternalServiceError = InternalServiceError;
class NotImplementedError extends HttpError {
    constructor(message) {
        super(501, message);
    }
}
exports.NotImplementedError = NotImplementedError;
class BadGatewayError extends HttpError {
    constructor(message) {
        super(502, message);
    }
}
exports.BadGatewayError = BadGatewayError;
class ServiceUnavailableError extends HttpError {
    constructor(message) {
        super(503, message);
    }
}
exports.ServiceUnavailableError = ServiceUnavailableError;
class GatewayTimeoutError extends HttpError {
    constructor(message) {
        super(504, message);
    }
}
exports.GatewayTimeoutError = GatewayTimeoutError;
function isHttpError(error) {
    return error instanceof Error && 'status' in error;
}
function getErrorMessage(error) {
    try {
        const parsedMessage = JSON.parse(error.message);
        if ('message' in parsedMessage) {
            const message = parsedMessage.message;
            return typeof message === 'string' ? message : JSON.stringify(message);
        }
    }
    catch (_a) {
        /* empty */
    }
    return error.message;
}
function getMessageIfHttpError(error) {
    if (isHttpError(error)) {
        return getErrorMessage(error);
    }
}
function isError(error) {
    return typeof error === 'object' && !!error && 'message' in error;
}
function getMessageIfError(error) {
    if (isError(error)) {
        return getErrorMessage(error);
    }
}
//# sourceMappingURL=errors.js.map