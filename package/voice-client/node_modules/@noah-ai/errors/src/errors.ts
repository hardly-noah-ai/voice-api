const transformNonJsonStringToJsonString = (message?: string) => {
  if (!message) {
    return;
  }
  try {
    JSON.parse(message);
    return message;
  } catch {
    return JSON.stringify({ message });
  }
};
export class HttpError extends Error {
  status: number;

  constructor(status: number, message?: string) {
    super(transformNonJsonStringToJsonString(message));
    this.status = status;
  }
}

export class NotUpdatedError extends HttpError {
  constructor(message?: string) {
    super(304, message);
  }
}

export class BadRequestError extends HttpError {
  constructor(message?: string) {
    super(400, message);
  }
}

export class BadParameterError extends HttpError {
  constructor(message?: string) {
    super(400, message);
  }
}

export class UnauthorizedError extends HttpError {
  constructor(message?: string) {
    super(401, message);
  }
}

export class ForbiddenError extends HttpError {
  constructor(message?: string) {
    super(403, message);
  }
}

export class NotFoundError extends HttpError {
  constructor(message?: string) {
    super(404, message);
  }
}

export class ConflictError extends HttpError {
  constructor(message?: string) {
    super(409, message);
  }
}

export class InternalServiceError extends HttpError {
  constructor(message?: string) {
    super(500, message);
  }
}

export class NotImplementedError extends HttpError {
  constructor(message?: string) {
    super(501, message);
  }
}

export class BadGatewayError extends HttpError {
  constructor(message?: string) {
    super(502, message);
  }
}

export class ServiceUnavailableError extends HttpError {
  constructor(message?: string) {
    super(503, message);
  }
}

export class GatewayTimeoutError extends HttpError {
  constructor(message?: string) {
    super(504, message);
  }
}

export function isHttpError(error: unknown): error is HttpError {
  return error instanceof Error && 'status' in error;
}

export function getErrorMessage(error: Error): string {
  try {
    const parsedMessage = JSON.parse(error.message);
    if ('message' in parsedMessage) {
      const message = parsedMessage.message;
      return typeof message === 'string' ? message : JSON.stringify(message);
    }
  } catch {
    /* empty */
  }
  return error.message;
}

export function getMessageIfHttpError(error: unknown) {
  if (isHttpError(error)) {
    return getErrorMessage(error);
  }
}

export function isError(error: unknown): error is Error {
  return typeof error === 'object' && !!error && 'message' in error;
}

export function getMessageIfError(error: unknown) {
  if (isError(error)) {
    return getErrorMessage(error);
  }
}
