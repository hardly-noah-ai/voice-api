import { AST_NODE_TYPES, TSESLint } from "@typescript-eslint/utils";
import {
  CallExpressionArgument,
  Decorator,
  Expression,
  Identifier,
  PrivateIdentifier,
  TypeNode,
} from "node_modules/@typescript-eslint/types/dist/generated/ast-spec";

function castToArray<T>(item: T | T[]): T[] {
  return Array.isArray(item) ? item : [item];
}

function isIdentifierOfName(
  expression: Expression | PrivateIdentifier,
  names: string | string[]
): expression is Identifier {
  return (
    expression.type === AST_NODE_TYPES.Identifier &&
    castToArray(names).includes(expression.name)
  );
}

function isGettingTypeFromContainerTypes(nodes: TypeNode | TypeNode[]) {
  return castToArray(nodes).some(
    (node) =>
      node.type === AST_NODE_TYPES.TSIndexedAccessType &&
      node.objectType.type === AST_NODE_TYPES.TSTypeReference &&
      node.objectType.typeName.type === AST_NODE_TYPES.Identifier &&
      node.objectType.typeName.name === "ContainerTypes"
  );
}

function isAccessingUsingAnIndexRelatedToValue(
  typeArguments: TypeNode | TypeNode[],
  value: string
) {
  return castToArray(typeArguments)
    .filter((typeArg) => typeArg.type === AST_NODE_TYPES.TSIndexedAccessType)
    .map((typeArg) => typeArg.indexType)
    .filter((indexType) => indexType.type === AST_NODE_TYPES.TSLiteralType)
    .map((indexType) => indexType.literal)
    .filter((literal) => literal.type === AST_NODE_TYPES.Literal)
    .map((literal) => literal.value)
    .filter((literalValue) => literalValue !== null)
    .some((literalValue) =>
      [value, ...value.split("#")].includes(literalValue.toString())
    );
}

function getFirstArgIfString(args: CallExpressionArgument[]) {
  const [firstArg] = args;
  if (
    firstArg.type === AST_NODE_TYPES.Literal &&
    typeof firstArg.value === "string"
  ) {
    return firstArg.value;
  }
}

function getInjectDecorator(decorators: Decorator[]) {
  return decorators
    .map((decorator) => decorator.expression)
    .filter((expression) => expression.type === "CallExpression")
    .find(
      (expression) =>
        expression.callee.type === "Identifier" &&
        expression.callee.name === "inject"
    );
}

export const MESSSAGE_IDS = [
  "explicitGenerics",
  "typeArgumentReference",
  "relatedTypeReference",
  "injectTypeArgumentReference",
  "injectRelatedTypeReference",
] as const;

const rule: TSESLint.RuleModule<(typeof MESSSAGE_IDS)[number], []> = {
  meta: {
    type: "problem",
    docs: {
      description:
        "Require explicit generics for tsyringe container functions when using a string injection token",
    },
    schema: [],
    messages: {
      explicitGenerics: `Use explicit generics when calling container with a string injection token`,
      typeArgumentReference: `Type argument must reference a type from ContainerTypes when calling container with a string injection token`,
      relatedTypeReference: `Type argument must reference a type related to the string when calling container with a string injection token`,
      injectTypeArgumentReference: `Type argument must reference a type from ContainerTypes when using inject with a string injection token`,
      injectRelatedTypeReference: `Type argument must reference a type related to the string when using inject with a string injection token`,
    },
  },
  defaultOptions: [],
  create(context) {
    return {
      CallExpression(node) {
        const { callee } = node;
        if (
          callee.type !== AST_NODE_TYPES.MemberExpression ||
          !isIdentifierOfName(callee.object, "container") ||
          !isIdentifierOfName(callee.property, ["resolve", "register"])
        ) {
          return;
        }

        const firstArg = getFirstArgIfString(node.arguments);
        if (!firstArg) {
          return;
        }

        const typeArguments = node.typeArguments?.params;
        if (!typeArguments) {
          context.report({
            node,
            messageId: "explicitGenerics",
          });
          return;
        }

        if (!isGettingTypeFromContainerTypes(typeArguments)) {
          context.report({
            node,
            messageId: "typeArgumentReference",
          });
          return;
        }

        if (!isAccessingUsingAnIndexRelatedToValue(typeArguments, firstArg)) {
          context.report({
            node,
            messageId: "relatedTypeReference",
          });
          return;
        }
      },

      MethodDefinition(node) {
        if (node.kind !== "constructor") {
          return;
        }

        for (const param of node.value.params) {
          const injectDecorator = getInjectDecorator(param.decorators);
          if (!injectDecorator) {
            continue;
          }

          const firstArg = getFirstArgIfString(injectDecorator.arguments);
          if (!firstArg) {
            continue;
          }

          const typeAnnotation =
            param.type === "TSParameterProperty"
              ? param.parameter.typeAnnotation?.typeAnnotation
              : param.typeAnnotation?.typeAnnotation;

          if (
            !typeAnnotation ||
            !isGettingTypeFromContainerTypes(typeAnnotation)
          ) {
            context.report({
              node,
              messageId: "injectTypeArgumentReference",
            });
            continue;
          }

          if (
            !isAccessingUsingAnIndexRelatedToValue(typeAnnotation, firstArg)
          ) {
            context.report({
              node,
              messageId: "injectRelatedTypeReference",
            });
            continue;
          }
        }
      },
    };
  },
};

export default rule;
