"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = require("@hpx-it/errors");
const src_1 = require("../../src");
const getMockResponse = (overrides) => (Object.assign({ ok: true, json: () => 'woo', headers: { get: () => null } }, overrides));
const mockFetch = jest.fn();
global.fetch = mockFetch;
describe('performRequest', () => {
    beforeEach(() => {
        jest.clearAllMocks();
    });
    it('HttpError should match RequestError', () => {
        expect(src_1.RequestError).toStrictEqual(errors_1.HttpError);
    });
    it('should default perform get request and json result', () => __awaiter(void 0, void 0, void 0, function* () {
        mockFetch.mockResolvedValue(getMockResponse());
        const result = yield (0, src_1.performRequest)('url');
        expect(mockFetch).toBeCalledTimes(1);
        expect(mockFetch).toBeCalledWith('url', {});
        expect(result).toStrictEqual('woo');
    }));
    it('should throw HttpError if res not ok', () => __awaiter(void 0, void 0, void 0, function* () {
        mockFetch.mockResolvedValue(getMockResponse({ ok: false, text: () => 'oops', status: 400 }));
        yield expect((0, src_1.performRequest)('url')).rejects.toThrow(new errors_1.HttpError(400, 'oops'));
    }));
    describe('auto retry', () => {
        it('should auto retry fetch failed once', () => __awaiter(void 0, void 0, void 0, function* () {
            mockFetch
                .mockRejectedValueOnce(new Error('fetch failed'))
                .mockResolvedValue(getMockResponse());
            const result = yield (0, src_1.performRequest)('url');
            expect(mockFetch).toBeCalledTimes(2);
            expect(mockFetch).toBeCalledWith('url', {});
            expect(result).toStrictEqual('woo');
        }));
        it('should only auto retry fetch failed once', () => __awaiter(void 0, void 0, void 0, function* () {
            mockFetch
                .mockRejectedValueOnce(new Error('fetch failed'))
                .mockRejectedValue(new Error('fetch failed'));
            yield expect((0, src_1.performRequest)('url')).rejects.toThrow(new Error('fetch failed'));
            expect(mockFetch).toBeCalledTimes(2);
        }));
        it('should auto google error once', () => __awaiter(void 0, void 0, void 0, function* () {
            const mockLog = jest.fn();
            mockFetch
                .mockResolvedValueOnce(getMockResponse({
                ok: false,
                status: 500,
                text: () => '\n<html><head>\n<meta http-equiv="content-type" content="text/html;charset=utf-8">\n<title>500 Server Error</title>\n</head>\n<body text=#000000 bgcolor=#ffffff>\n<h1>Error: Server Error</h1>\n<h2>The server encountered an error and could not complete your request.<p>Please try again in 30 seconds.</h2>\n<h2></h2>\n</body></html>\n',
            }))
                .mockResolvedValue(getMockResponse());
            const result = yield (0, src_1.performRequest)('url', { log: mockLog });
            expect(mockFetch).toBeCalledTimes(2);
            expect(mockFetch).toBeCalledWith('url', {});
            expect(mockLog).toHaveBeenCalledWith('RETRY fetch on response: {"message":"\\n<html><head>\\n<meta http-equiv=\\"content-type\\" content=\\"text/html;charset=utf-8\\">\\n<title>500 Server Error</title>\\n</head>\\n<body text=#000000 bgcolor=#ffffff>\\n<h1>Error: Server Error</h1>\\n<h2>The server encountered an error and could not complete your request.<p>Please try again in 30 seconds.</h2>\\n<h2></h2>\\n</body></html>\\n"}', { error: expect.any(Error), status: 500 });
            expect(result).toStrictEqual('woo');
        }));
        it('should only auto retry google error once', () => __awaiter(void 0, void 0, void 0, function* () {
            mockFetch.mockResolvedValue(getMockResponse({
                ok: false,
                status: 500,
                text: () => '\n<html><head>\n<meta http-equiv="content-type" content="text/html;charset=utf-8">\n<title>500 Server Error</title>\n</head>\n<body text=#000000 bgcolor=#ffffff>\n<h1>Error: Server Error</h1>\n<h2>The server encountered an error and could not complete your request.<p>Please try again in 30 seconds.</h2>\n<h2></h2>\n</body></html>\n',
            }));
            yield expect((0, src_1.performRequest)('url')).rejects.toThrow(new errors_1.HttpError(500, '{"message":"\\n<html><head>\\n<meta http-equiv=\\"content-type\\" content=\\"text/html;charset=utf-8\\">\\n<title>500 Server Error</title>\\n</head>\\n<body text=#000000 bgcolor=#ffffff>\\n<h1>Error: Server Error</h1>\\n<h2>The server encountered an error and could not complete your request.<p>Please try again in 30 seconds.</h2>\\n<h2></h2>\\n</body></html>\\n"}'));
            expect(mockFetch).toBeCalledTimes(2);
        }));
        it('should log retry when occurs', () => __awaiter(void 0, void 0, void 0, function* () {
            const mockLog = jest.fn();
            mockFetch
                .mockRejectedValueOnce(new Error('fetch failed'))
                .mockResolvedValue(getMockResponse());
            yield (0, src_1.performRequest)('url', { log: mockLog });
            expect(mockLog).toHaveBeenCalledTimes(1);
            expect(mockLog).toHaveBeenCalledWith('RETRY fetch on error: fetch failed', {
                url: 'url',
                error: new Error('fetch failed'),
            });
        }));
        it('should not retry non fetch failed errors', () => __awaiter(void 0, void 0, void 0, function* () {
            mockFetch.mockRejectedValueOnce(new Error('not fetch failed'));
            yield expect((0, src_1.performRequest)('url')).rejects.toThrow(new Error('not fetch failed'));
            expect(mockFetch).toBeCalledTimes(1);
        }));
    });
    it('should throw HttpError with text in message', () => __awaiter(void 0, void 0, void 0, function* () {
        mockFetch.mockResolvedValue(getMockResponse({
            ok: false,
            text: () => JSON.stringify({ message: 'oops' }),
            status: 400,
        }));
        yield expect((0, src_1.performRequest)('url')).rejects.toThrow(new errors_1.HttpError(400, 'oops'));
    }));
    it('should throw HttpError with stringified json if no message', () => __awaiter(void 0, void 0, void 0, function* () {
        mockFetch.mockResolvedValue(getMockResponse({
            ok: false,
            text: () => JSON.stringify({ not_message: 'oops' }),
            status: 400,
        }));
        yield expect((0, src_1.performRequest)('url')).rejects.toThrow(new errors_1.HttpError(400, JSON.stringify({ not_message: 'oops' })));
    }));
    it('should return undefined when 204', () => __awaiter(void 0, void 0, void 0, function* () {
        mockFetch.mockResolvedValue(getMockResponse({ ok: true, status: 204 }));
        expect(yield (0, src_1.performRequest)('url')).toStrictEqual(undefined);
    }));
    it('should return undefined when 200 and no content', () => __awaiter(void 0, void 0, void 0, function* () {
        mockFetch.mockResolvedValue(getMockResponse({
            ok: true,
            status: 200,
            headers: {
                get: (header) => (header === 'content-length' ? '0' : null),
            },
        }));
        expect(yield (0, src_1.performRequest)('url')).toStrictEqual(undefined);
    }));
    it('should be able to define a timeout', () => __awaiter(void 0, void 0, void 0, function* () {
        let signal;
        mockFetch.mockImplementation((_url, options) => __awaiter(void 0, void 0, void 0, function* () {
            yield new Promise((resolve) => setTimeout(resolve, 20));
            signal = options.signal;
            return getMockResponse({
                ok: true,
                json: () => 'woo',
            });
        }));
        yield (0, src_1.performRequest)('url', { timeout: 10 });
        expect(signal === null || signal === void 0 ? void 0 : signal.aborted).toStrictEqual(true);
    }));
    it('should handle query strings for get requests', () => __awaiter(void 0, void 0, void 0, function* () {
        mockFetch.mockResolvedValue(getMockResponse({ ok: true, json: () => 'woo' }));
        yield (0, src_1.performRequest)('url', {
            qs: {
                query_string: 'qs',
                query_string_array: [0, 1],
                query_string_nested: { query_string: 'qs' },
                query_string_nested_array: [
                    { query_string: 'qs' },
                    { query_string: 'qs2' },
                ],
                date_query_string: new Date('2022-01-01'),
                no_query_string: undefined,
            },
        });
        expect(mockFetch).toBeCalledTimes(1);
        expect(mockFetch).toBeCalledWith('url?query_string=qs&query_string_array=0&query_string_array=1&query_string_nested%5Bquery_string%5D=qs&query_string_nested_array%5Bquery_string%5D=qs&query_string_nested_array%5Bquery_string%5D=qs2&date_query_string=2022-01-01T00%3A00%3A00.000Z', {});
    }));
    it('should return response if responseType is response', () => __awaiter(void 0, void 0, void 0, function* () {
        const res = getMockResponse({ ok: true, blah: 'boo' });
        mockFetch.mockResolvedValue(res);
        expect(yield (0, src_1.performRequest)('url', { responseType: 'response' })).toStrictEqual(res);
    }));
    it('should return blob if responseType is blob', () => __awaiter(void 0, void 0, void 0, function* () {
        mockFetch.mockResolvedValue(getMockResponse({ ok: true, blob: () => 'woo' }));
        expect(yield (0, src_1.performRequest)('url', { responseType: 'blob' })).toStrictEqual('woo');
    }));
    it('should return text if responseType is text', () => __awaiter(void 0, void 0, void 0, function* () {
        mockFetch.mockResolvedValue(getMockResponse({ ok: true, text: () => 'woo' }));
        expect(yield (0, src_1.performRequest)('url', { responseType: 'text' })).toStrictEqual('woo');
    }));
});
//# sourceMappingURL=preformRequest.test.js.map