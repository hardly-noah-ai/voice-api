"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RequestError = void 0;
exports.getContent = getContent;
exports.performRequest = performRequest;
const errors_1 = require("@noah-ai/errors");
Object.defineProperty(exports, "RequestError", { enumerable: true, get: function () { return errors_1.HttpError; } });
const lodash_1 = require("lodash");
const FETCH_RETRY_ERROR_MESSAGES = ['fetch failed', 'terminated'];
const RESPONSE_RETRY_ERROR_MESSAGES = [
    'terminated',
    '{"message":"\\n<html><head>\\n<meta http-equiv=\\"content-type\\" content=\\"text/html;charset=utf-8\\">\\n<title>500 Server Error</title>\\n</head>\\n<body text=#000000 bgcolor=#ffffff>\\n<h1>Error: Server Error</h1>\\n<h2>The server encountered an error and could not complete your request.<p>Please try again in 30 seconds.</h2>\\n<h2></h2>\\n</body></html>\\n"}',
    '{"message":"\\n<html><head>\\n<meta http-equiv=\\"content-type\\" content=\\"text/html;charset=utf-8\\">\\n<title>502 Server Error</title>\\n</head>\\n<body text=#000000 bgcolor=#ffffff>\\n<h1>Error: Server Error</h1>\\n<h2>The server encountered a temporary error and could not complete your request.<p>Please try again in 30 seconds.</h2>\\n<h2></h2>\\n</body></html>\\n"}',
    '{"message":"\\n<html><head>\\n<meta http-equiv=\\"content-type\\" content=\\"text/html;charset=utf-8\\">\\n<title>503 Server Error</title>\\n</head>\\n<body text=#000000 bgcolor=#ffffff>\\n<h1>Error: Server Error</h1>\\n<h2>The service you requested is not available at this time.<p>Service error -27.</h2>\\n<h2></h2>\\n</body></html>\\n"}',
];
function endpoint(url, options) {
    return `${url}${(options === null || options === void 0 ? void 0 : options.qs) ? `?${getUrlQueryString(options.qs)}` : ''}`;
}
function getUrlQueryString(query) {
    const urlParams = new URLSearchParams();
    for (const [key, value] of Object.entries(query)) {
        processQueryObjectValue(urlParams, key, value);
    }
    return urlParams.toString();
}
function processQueryObjectValue(urlParams, key, value) {
    if (value == null) {
        // ignore undefined and null values
    }
    else if (Array.isArray(value)) {
        value.forEach((arrayValue) => {
            processQueryObjectValue(urlParams, key, arrayValue);
        });
    }
    else if (value instanceof Date) {
        urlParams.append(key, value.toISOString());
    }
    else if (typeof value === 'object') {
        Object.entries(value).forEach(([vKey, vValue]) => {
            processQueryObjectValue(urlParams, `${key}[${vKey}]`, vValue);
        });
    }
    else {
        urlParams.append(key, value.toString());
    }
}
function checkResponseOk(res) {
    return __awaiter(this, void 0, void 0, function* () {
        if (res.ok) {
            return;
        }
        const bodyText = yield res.text();
        let bodyJSON;
        try {
            bodyJSON = JSON.parse(bodyText);
        }
        catch (_a) {
            throw new errors_1.HttpError(res.status, bodyText);
        }
        const message = typeof bodyJSON.message === 'string'
            ? bodyJSON.message
            : JSON.stringify(bodyJSON);
        throw new errors_1.HttpError(res.status, message);
    });
}
function getContent(res, resType) {
    return __awaiter(this, void 0, void 0, function* () {
        return resType === 'response'
            ? res
            : res.status === 204 || res.headers.get('content-length') === '0'
                ? undefined
                : yield res[resType !== null && resType !== void 0 ? resType : 'json']();
    });
}
function fetchWithRequestOptions(url, requestOptions, controller) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield fetch(url, Object.assign(Object.assign({}, (controller && { signal: controller.signal })), (0, lodash_1.omit)(requestOptions, ['qs', 'timeout', 'responseType', 'log'])));
    });
}
function fetchWithTimeout(url, requestOptions) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a;
        const { timeout } = requestOptions;
        const controller = timeout ? new AbortController() : undefined;
        const id = controller
            ? setTimeout(() => {
                controller.abort();
            }, timeout)
            : undefined;
        try {
            return yield fetchWithRequestOptions(url, requestOptions, controller);
        }
        catch (error) {
            if (error instanceof Error &&
                FETCH_RETRY_ERROR_MESSAGES.includes(error.message)) {
                (_a = requestOptions.log) === null || _a === void 0 ? void 0 : _a.call(requestOptions, `RETRY fetch on error: ${error.message}`, {
                    url,
                    error,
                });
                return yield fetchWithRequestOptions(url, requestOptions, controller);
            }
            throw error;
        }
        finally {
            if (id) {
                clearTimeout(id);
            }
        }
    });
}
function fetchAndCheck(uri, requestOptions) {
    return __awaiter(this, void 0, void 0, function* () {
        const res = yield fetchWithTimeout(uri, requestOptions);
        yield checkResponseOk(res);
        return res;
    });
}
function fetchAndCheckWithRetries(uri_1) {
    return __awaiter(this, arguments, void 0, function* (uri, requestOptions = {}) {
        var _a;
        try {
            return yield fetchAndCheck(uri, requestOptions);
        }
        catch (error) {
            if ((0, errors_1.isHttpError)(error) &&
                RESPONSE_RETRY_ERROR_MESSAGES.includes(error.message)) {
                (_a = requestOptions.log) === null || _a === void 0 ? void 0 : _a.call(requestOptions, `RETRY fetch on response: ${error.message}`, {
                    status: error.status,
                    error,
                });
                return yield fetchAndCheck(uri, requestOptions);
            }
            throw error;
        }
    });
}
function performRequest(url, requestOptions) {
    return __awaiter(this, void 0, void 0, function* () {
        const uri = endpoint(url, requestOptions);
        const res = yield fetchAndCheckWithRetries(uri, requestOptions);
        const result = (yield getContent(res, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.responseType));
        return result;
    });
}
//# sourceMappingURL=performRequest.js.map