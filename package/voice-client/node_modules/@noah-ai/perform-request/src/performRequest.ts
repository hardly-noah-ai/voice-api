import { HttpError, isHttpError } from '@noah-ai/errors';
import { omit } from 'lodash';

const FETCH_RETRY_ERROR_MESSAGES = ['fetch failed', 'terminated'];

const RESPONSE_RETRY_ERROR_MESSAGES = [
  'terminated',
  '{"message":"\\n<html><head>\\n<meta http-equiv=\\"content-type\\" content=\\"text/html;charset=utf-8\\">\\n<title>500 Server Error</title>\\n</head>\\n<body text=#000000 bgcolor=#ffffff>\\n<h1>Error: Server Error</h1>\\n<h2>The server encountered an error and could not complete your request.<p>Please try again in 30 seconds.</h2>\\n<h2></h2>\\n</body></html>\\n"}',
  '{"message":"\\n<html><head>\\n<meta http-equiv=\\"content-type\\" content=\\"text/html;charset=utf-8\\">\\n<title>502 Server Error</title>\\n</head>\\n<body text=#000000 bgcolor=#ffffff>\\n<h1>Error: Server Error</h1>\\n<h2>The server encountered a temporary error and could not complete your request.<p>Please try again in 30 seconds.</h2>\\n<h2></h2>\\n</body></html>\\n"}',
  '{"message":"\\n<html><head>\\n<meta http-equiv=\\"content-type\\" content=\\"text/html;charset=utf-8\\">\\n<title>503 Server Error</title>\\n</head>\\n<body text=#000000 bgcolor=#ffffff>\\n<h1>Error: Server Error</h1>\\n<h2>The service you requested is not available at this time.<p>Service error -27.</h2>\\n<h2></h2>\\n</body></html>\\n"}',
];

export { HttpError as RequestError };

type QueryObjectValue =
  | undefined
  | string
  | number
  | boolean
  | Date
  | QueryObjectValue[]
  | NestedQueryObject
  | NestedQueryObject[]
  | null;

export type QueryObject = Record<string, QueryObjectValue>;

// eslint-disable-next-line @typescript-eslint/no-empty-object-type
interface NestedQueryObject extends QueryObject {}

type ResponseType = 'json' | 'blob' | 'text' | 'response';

// Override RequestInit and add qs and headers.
export type PerformRequestOptions = RequestInit & {
  qs?: QueryObject;
  responseType?: ResponseType;
  timeout?: number;
  log?: (message: string, metadata?: object) => void;
};

function endpoint(url: string, options?: PerformRequestOptions): string {
  return `${url}${options?.qs ? `?${getUrlQueryString(options.qs)}` : ''}`;
}

function getUrlQueryString(query: QueryObject): string {
  const urlParams = new URLSearchParams();
  for (const [key, value] of Object.entries(query)) {
    processQueryObjectValue(urlParams, key, value);
  }
  return urlParams.toString();
}

function processQueryObjectValue(
  urlParams: URLSearchParams,
  key: string,
  value: QueryObjectValue,
) {
  if (value == null) {
    // ignore undefined and null values
  } else if (Array.isArray(value)) {
    value.forEach((arrayValue: QueryObjectValue) => {
      processQueryObjectValue(urlParams, key, arrayValue);
    });
  } else if (value instanceof Date) {
    urlParams.append(key, value.toISOString());
  } else if (typeof value === 'object') {
    Object.entries(value).forEach(([vKey, vValue]) => {
      processQueryObjectValue(urlParams, `${key}[${vKey}]`, vValue);
    });
  } else {
    urlParams.append(key, value.toString());
  }
}

async function checkResponseOk(res: Response): Promise<void> {
  if (res.ok) {
    return;
  }
  const bodyText = await res.text();
  let bodyJSON;
  try {
    bodyJSON = JSON.parse(bodyText);
  } catch {
    throw new HttpError(res.status, bodyText);
  }
  const message =
    typeof bodyJSON.message === 'string'
      ? bodyJSON.message
      : JSON.stringify(bodyJSON);
  throw new HttpError(res.status, message);
}

export async function getContent(
  res: Response,
  resType?: ResponseType,
): Promise<unknown> {
  return resType === 'response'
    ? res
    : res.status === 204 || res.headers.get('content-length') === '0'
    ? undefined
    : await res[resType ?? 'json']();
}

async function fetchWithRequestOptions(
  url: string,
  requestOptions: PerformRequestOptions,
  controller?: AbortController,
) {
  return await fetch(url, {
    ...(controller && { signal: controller.signal }),
    ...omit(requestOptions, ['qs', 'timeout', 'responseType', 'log']),
  });
}

async function fetchWithTimeout(
  url: string,
  requestOptions: PerformRequestOptions,
) {
  const { timeout } = requestOptions;
  const controller = timeout ? new AbortController() : undefined;
  const id = controller
    ? setTimeout(() => {
        controller.abort();
      }, timeout)
    : undefined;

  try {
    return await fetchWithRequestOptions(url, requestOptions, controller);
  } catch (error) {
    if (
      error instanceof Error &&
      FETCH_RETRY_ERROR_MESSAGES.includes(error.message)
    ) {
      requestOptions.log?.(`RETRY fetch on error: ${error.message}`, {
        url,
        error,
      });
      return await fetchWithRequestOptions(url, requestOptions, controller);
    }
    throw error;
  } finally {
    if (id) {
      clearTimeout(id);
    }
  }
}

async function fetchAndCheck(
  uri: string,
  requestOptions: PerformRequestOptions,
) {
  const res = await fetchWithTimeout(uri, requestOptions);
  await checkResponseOk(res);
  return res;
}

async function fetchAndCheckWithRetries(
  uri: string,
  requestOptions: PerformRequestOptions = {},
) {
  try {
    return await fetchAndCheck(uri, requestOptions);
  } catch (error) {
    if (
      isHttpError(error) &&
      RESPONSE_RETRY_ERROR_MESSAGES.includes(error.message)
    ) {
      requestOptions.log?.(`RETRY fetch on response: ${error.message}`, {
        status: error.status,
        error,
      });
      return await fetchAndCheck(uri, requestOptions);
    }
    throw error;
  }
}

export async function performRequest<T>(
  url: string,
  requestOptions?: PerformRequestOptions,
) {
  const uri = endpoint(url, requestOptions);
  const res = await fetchAndCheckWithRetries(uri, requestOptions);
  const result = (await getContent(res, requestOptions?.responseType)) as T;
  return result;
}
