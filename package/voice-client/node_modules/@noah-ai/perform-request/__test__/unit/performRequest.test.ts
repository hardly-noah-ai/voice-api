import { HttpError } from '@noah-ai/errors';
import { RequestError, performRequest } from '../../src';
import { getContent } from '../../src/performRequest';

const getMockResponse = (overrides?: object) => ({
  ok: true,
  json: () => 'woo',
  headers: { get: () => null },
  ...overrides,
});

const mockFetch = jest.fn();
global.fetch = mockFetch;

describe('performRequest', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('HttpError should match RequestError', () => {
    expect(RequestError).toStrictEqual(HttpError);
  });

  it('should default perform get request and json result', async () => {
    mockFetch.mockResolvedValue(getMockResponse());
    const result = await performRequest('url');
    expect(mockFetch).toBeCalledTimes(1);
    expect(mockFetch).toBeCalledWith('url', {});
    expect(result).toStrictEqual('woo');
  });

  it('should throw HttpError if res not ok', async () => {
    mockFetch.mockResolvedValue(
      getMockResponse({ ok: false, text: () => 'oops', status: 400 }),
    );
    await expect(performRequest('url')).rejects.toThrow(
      new HttpError(400, 'oops'),
    );
  });

  describe('auto retry', () => {
    it('should auto retry fetch failed once', async () => {
      mockFetch
        .mockRejectedValueOnce(new Error('fetch failed'))
        .mockResolvedValue(getMockResponse());

      const result = await performRequest('url');

      expect(mockFetch).toBeCalledTimes(2);
      expect(mockFetch).toBeCalledWith('url', {});
      expect(result).toStrictEqual('woo');
    });

    it('should only auto retry fetch failed once', async () => {
      mockFetch
        .mockRejectedValueOnce(new Error('fetch failed'))
        .mockRejectedValue(new Error('fetch failed'));

      await expect(performRequest('url')).rejects.toThrow(
        new Error('fetch failed'),
      );
      expect(mockFetch).toBeCalledTimes(2);
    });

    it('should auto google error once', async () => {
      const mockLog = jest.fn();
      mockFetch
        .mockResolvedValueOnce(
          getMockResponse({
            ok: false,
            status: 500,
            text: () =>
              '\n<html><head>\n<meta http-equiv="content-type" content="text/html;charset=utf-8">\n<title>500 Server Error</title>\n</head>\n<body text=#000000 bgcolor=#ffffff>\n<h1>Error: Server Error</h1>\n<h2>The server encountered an error and could not complete your request.<p>Please try again in 30 seconds.</h2>\n<h2></h2>\n</body></html>\n',
          }),
        )
        .mockResolvedValue(getMockResponse());

      const result = await performRequest('url', { log: mockLog });

      expect(mockFetch).toBeCalledTimes(2);
      expect(mockFetch).toBeCalledWith('url', {});
      expect(mockLog).toHaveBeenCalledWith(
        'RETRY fetch on response: {"message":"\\n<html><head>\\n<meta http-equiv=\\"content-type\\" content=\\"text/html;charset=utf-8\\">\\n<title>500 Server Error</title>\\n</head>\\n<body text=#000000 bgcolor=#ffffff>\\n<h1>Error: Server Error</h1>\\n<h2>The server encountered an error and could not complete your request.<p>Please try again in 30 seconds.</h2>\\n<h2></h2>\\n</body></html>\\n"}',
        { error: expect.any(Error), status: 500 },
      );
      expect(result).toStrictEqual('woo');
    });

    it('should only auto retry google error once (Server encountered an error)', async () => {
      mockFetch.mockResolvedValue(
        getMockResponse({
          ok: false,
          status: 500,
          text: () =>
            '\n<html><head>\n<meta http-equiv="content-type" content="text/html;charset=utf-8">\n<title>500 Server Error</title>\n</head>\n<body text=#000000 bgcolor=#ffffff>\n<h1>Error: Server Error</h1>\n<h2>The server encountered an error and could not complete your request.<p>Please try again in 30 seconds.</h2>\n<h2></h2>\n</body></html>\n',
        }),
      );

      await expect(performRequest('url')).rejects.toThrow(
        new HttpError(
          500,
          '{"message":"\\n<html><head>\\n<meta http-equiv=\\"content-type\\" content=\\"text/html;charset=utf-8\\">\\n<title>500 Server Error</title>\\n</head>\\n<body text=#000000 bgcolor=#ffffff>\\n<h1>Error: Server Error</h1>\\n<h2>The server encountered an error and could not complete your request.<p>Please try again in 30 seconds.</h2>\\n<h2></h2>\\n</body></html>\\n"}',
        ),
      );
      expect(mockFetch).toBeCalledTimes(2);
    });

    it('should only auto retry google error once (Temporary error)', async () => {
      mockFetch.mockResolvedValue(
        getMockResponse({
          ok: false,
          status: 500,
          text: () =>
            '\n<html><head>\n<meta http-equiv="content-type" content="text/html;charset=utf-8">\n<title>502 Server Error</title>\n</head>\n<body text=#000000 bgcolor=#ffffff>\n<h1>Error: Server Error</h1>\n<h2>The server encountered a temporary error and could not complete your request.<p>Please try again in 30 seconds.</h2>\n<h2></h2>\n</body></html>\n',
        }),
      );

      await expect(performRequest('url')).rejects.toThrow(
        new HttpError(
          500,
          '{"message":"\\n<html><head>\\n<meta http-equiv=\\"content-type\\" content=\\"text/html;charset=utf-8\\">\\n<title>502 Server Error</title>\\n</head>\\n<body text=#000000 bgcolor=#ffffff>\\n<h1>Error: Server Error</h1>\\n<h2>The server encountered a temporary error and could not complete your request.<p>Please try again in 30 seconds.</h2>\\n<h2></h2>\\n</body></html>\\n"}',
        ),
      );
      expect(mockFetch).toBeCalledTimes(2);
    });

    it('should only auto retry google error once (Service not available)', async () => {
      mockFetch.mockResolvedValue(
        getMockResponse({
          ok: false,
          status: 500,
          text: () =>
            '\n<html><head>\n<meta http-equiv="content-type" content="text/html;charset=utf-8">\n<title>503 Server Error</title>\n</head>\n<body text=#000000 bgcolor=#ffffff>\n<h1>Error: Server Error</h1>\n<h2>The service you requested is not available at this time.<p>Service error -27.</h2>\n<h2></h2>\n</body></html>\n',
        }),
      );

      await expect(performRequest('url')).rejects.toThrow(
        new HttpError(
          500,
          '{"message":"\\n<html><head>\\n<meta http-equiv=\\"content-type\\" content=\\"text/html;charset=utf-8\\">\\n<title>503 Server Error</title>\\n</head>\\n<body text=#000000 bgcolor=#ffffff>\\n<h1>Error: Server Error</h1>\\n<h2>The service you requested is not available at this time.<p>Service error -27.</h2>\\n<h2></h2>\\n</body></html>\\n"}',
        ),
      );
      expect(mockFetch).toBeCalledTimes(2);
    });

    it('should log retry when occurs', async () => {
      const mockLog = jest.fn();
      mockFetch
        .mockRejectedValueOnce(new Error('fetch failed'))
        .mockResolvedValue(getMockResponse());

      await performRequest('url', { log: mockLog });

      expect(mockLog).toHaveBeenCalledTimes(1);
      expect(mockLog).toHaveBeenCalledWith(
        'RETRY fetch on error: fetch failed',
        {
          url: 'url',
          error: new Error('fetch failed'),
        },
      );
    });

    it('should not retry non fetch failed errors', async () => {
      mockFetch.mockRejectedValueOnce(new Error('not fetch failed'));

      await expect(performRequest('url')).rejects.toThrow(
        new Error('not fetch failed'),
      );
      expect(mockFetch).toBeCalledTimes(1);
    });
  });

  it('should throw HttpError with text in message', async () => {
    mockFetch.mockResolvedValue(
      getMockResponse({
        ok: false,
        text: () => JSON.stringify({ message: 'oops' }),
        status: 400,
      }),
    );
    await expect(performRequest('url')).rejects.toThrow(
      new HttpError(400, 'oops'),
    );
  });

  it('should throw HttpError with stringified json if no message', async () => {
    mockFetch.mockResolvedValue(
      getMockResponse({
        ok: false,
        text: () => JSON.stringify({ not_message: 'oops' }),
        status: 400,
      }),
    );
    await expect(performRequest('url')).rejects.toThrow(
      new HttpError(400, JSON.stringify({ not_message: 'oops' })),
    );
  });

  it('should return undefined when 204', async () => {
    mockFetch.mockResolvedValue(getMockResponse({ ok: true, status: 204 }));
    expect(await performRequest('url')).toStrictEqual(undefined);
  });

  it('should return undefined when 200 and no content', async () => {
    mockFetch.mockResolvedValue(
      getMockResponse({
        ok: true,
        status: 200,
        headers: {
          get: (header: string) => (header === 'content-length' ? '0' : null),
        },
      }),
    );
    expect(await performRequest('url')).toStrictEqual(undefined);
  });

  it('should be able to define a timeout', async () => {
    let signal: AbortSignal | null | undefined;
    mockFetch.mockImplementation(async (_url, options) => {
      await new Promise((resolve) => setTimeout(resolve, 20));
      signal = options.signal;
      return getMockResponse({
        ok: true,
        json: () => 'woo',
      });
    });
    await performRequest('url', { timeout: 10 });
    expect(signal?.aborted).toStrictEqual(true);
  });

  it('should handle query strings for get requests', async () => {
    mockFetch.mockResolvedValue(
      getMockResponse({ ok: true, json: () => 'woo' }),
    );
    await performRequest('url', {
      qs: {
        query_string: 'qs',
        query_string_array: [0, 1],
        query_string_nested: { query_string: 'qs' },
        query_string_nested_array: [
          { query_string: 'qs' },
          { query_string: 'qs2' },
        ],
        date_query_string: new Date('2022-01-01'),
        no_query_string: undefined,
      },
    });
    expect(mockFetch).toBeCalledTimes(1);
    expect(mockFetch).toBeCalledWith(
      'url?query_string=qs&query_string_array=0&query_string_array=1&query_string_nested%5Bquery_string%5D=qs&query_string_nested_array%5Bquery_string%5D=qs&query_string_nested_array%5Bquery_string%5D=qs2&date_query_string=2022-01-01T00%3A00%3A00.000Z',
      {},
    );
  });

  it('should return response if responseType is response', async () => {
    const res = getMockResponse({ ok: true, blah: 'boo' });
    mockFetch.mockResolvedValue(res);
    expect(
      await performRequest('url', { responseType: 'response' }),
    ).toStrictEqual(res);
  });

  it('should return blob if responseType is blob', async () => {
    mockFetch.mockResolvedValue(
      getMockResponse({ ok: true, blob: () => 'woo' }),
    );
    expect(await performRequest('url', { responseType: 'blob' })).toStrictEqual(
      'woo',
    );
  });

  it('should return text if responseType is text', async () => {
    mockFetch.mockResolvedValue(
      getMockResponse({ ok: true, text: () => 'woo' }),
    );
    expect(await performRequest('url', { responseType: 'text' })).toStrictEqual(
      'woo',
    );
  });

  describe('getContent', () => {
    test('Returns undefined if status 204', async () => {
      expect(
        await getContent({
          status: 204,
        } as never),
      ).toEqual(undefined);
    });

    test('Returns undefined if content-length === 0', async () => {
      expect(
        await getContent({
          headers: {
            get: () => '0',
          },
        } as never),
      ).toEqual(undefined);
    });

    test('Returns 1st arg if res-type === response', async () => {
      expect(await getContent('woo' as never, 'response')).toEqual('woo');
    });

    test('Returns json if resType not given and not undefined', async () => {
      expect(
        await getContent({
          json: () => 'woo',
          headers: {
            get: jest.fn(),
          },
        } as never),
      ).toEqual('woo');
    });

    test('Returns res.resType if resType given and not undefined', async () => {
      expect(
        await getContent(
          {
            woo: () => 'yay',
            headers: {
              get: jest.fn(),
            },
          } as never,
          'woo' as never,
        ),
      ).toEqual('yay');
    });
  });
});
